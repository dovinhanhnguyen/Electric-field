// Implementation file for charge class
// dvan2, Oct 2016

#include "charge.h"

// Constructor
Charge::Charge (int test_charge, int draw_charge, int sign_of_charge, vector2d initial_position, Charge list_of_source[]) {
  test_or_source = test_charge;
  draw_or_not = draw_charge;
  minus_or_plus = sign_of_charge;
  if (test_or_source == 1) minus_or_plus = 0;
  charge_position = initial_position;
  previous_charge_position = initial_position;
  charge_velocity = vector2d(0.0, 0.0);
  charge_acceleration = vector2d(0.0, 0.0);
  ptr_source_list = list_of_source;
}

// Electric field generated by this charge at position r in space
vector2d Charge::field_generated (vector2d r) {
  vector2d relative_position = r - charge_position;
  if ((relative_position.abs2()) <= SMALL_NUM) return vector2d(0.0, 0.0);
  else return (((pow(-1.0, (double)minus_or_plus))*CHARGE/(4*M_PI*PERMITTIVITY*(relative_position.abs2())))*(relative_position.norm()));
}

// Calculate the acceleration of this charge
void Charge::acceleration (void) {
  vector2d temp(0.0, 0.0);
  for (int i=0; i<MAX_NUM_SOURCE; i++) {
    temp += ((double)((ptr_source_list+i)->draw_or_not))*((ptr_source_list+i)->field_generated(charge_position));
    //cout << "Field due to source charge " << i << " is " << ((double)((ptr_source_list+i)->draw_or_not))*((ptr_source_list+i)->field_generated(charge_position)) << endl;
  }
  charge_acceleration = ((CHARGE/MASS)*temp);
}

// Mechanical simulation
void Charge::update_charge (void) {
  if (draw_or_not == 1) {
    acceleration();
    previous_charge_position = charge_position;
    charge_position = charge_position + charge_velocity*DELTA_T + (0.5*DELTA_T*DELTA_T)*charge_acceleration;
    charge_velocity = charge_velocity + DELTA_T*charge_acceleration;
  }
}

// Reset test charge when there is a mouse click
void Charge::reset_charge (vector2d initial_position) {
  test_or_source = 1;
  draw_or_not = 1;
  charge_position = initial_position;
  previous_charge_position = initial_position;
  charge_velocity = vector2d(0.0, 0.0);
  charge_acceleration = vector2d(0.0, 0.0);
}

// Detect when two opposite charges mesh together
void Charge::detect_collision (void) {
  double temp;
  for (int i=0; i<MAX_NUM_SOURCE; i++) {
    if ((ptr_source_list+i)->draw_or_not == 1) {
      temp = ((((ptr_source_list+i)->charge_position)-charge_position).abs());
      if (temp <= SCALE/50) {
        draw_or_not = 0;
        break;
      }
    }
  }
  if (draw_or_not == 0) cout << "Collision? " << draw_or_not << endl;
}
