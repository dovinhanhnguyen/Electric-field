// Implementation file for charge class
// dvan2, Oct 2016

#include "charge.h"

// Constructor
Charge::Charge (int test_charge, int draw_charge, int sign_of_charge, vector2d initial_position, Charge list_of_source[]) {
  test_or_source = test_charge;
  draw_or_not = draw_charge;
  minus_or_plus = sign_of_charge;
  switch_integrator = 0;
  if (test_or_source == 1) minus_or_plus = 0;
  charge_position = initial_position;
  previous_charge_position = initial_position;
  charge_velocity = vector2d(0.0, 0.0);
  charge_acceleration = vector2d(0.0, 0.0);
  ptr_source_list = list_of_source;
}

// Electric field generated by this charge at position r in space
vector2d Charge::field_generated (vector2d r) {
  vector2d relative_position = r - charge_position;
  if ((relative_position.abs2()) <= SMALL_NUM) return vector2d(0.0, 0.0);
  else return (((pow(-1.0, (double)minus_or_plus))*CHARGE/(4*M_PI*PERMITTIVITY*(relative_position.abs2())))*(relative_position.norm()));
}

// Calculate the acceleration of this charge
void Charge::acceleration (void) {
  vector2d temp(0.0, 0.0);
  for (int i=0; i<MAX_NUM_SOURCE; i++) {
    temp += ((double)((ptr_source_list+i)->draw_or_not))*((ptr_source_list+i)->field_generated(charge_position));
  }
  charge_acceleration = ((CHARGE/MASS)*temp);
}

// Mechanical simulation
void Charge::update_charge (void) {
  if (draw_or_not == 1) {
    vector2d temp(0.0, 0.0);
    
    acceleration();
    if (switch_integrator == 0) {
      previous_charge_position = charge_position;
      charge_position = charge_position + charge_velocity*DELTA_T + (0.5*DELTA_T*DELTA_T)*charge_acceleration;
      charge_velocity = charge_velocity + DELTA_T*charge_acceleration;
      switch_integrator = 1;
    }
    else {
      temp = charge_position;
      charge_position = charge_position*2.0 - previous_charge_position + (DELTA_T*DELTA_T)*charge_acceleration;
      previous_charge_position = temp;
      charge_velocity = (charge_position - previous_charge_position)/DELTA_T;
    }
  }
}

// Reset test charge when there is a mouse click
void Charge::reset_charge (vector2d initial_position) {
  test_or_source = 1;
  draw_or_not = 0;
  switch_integrator = 0;
  charge_position = initial_position;
  previous_charge_position = initial_position;
  charge_velocity = vector2d(0.0, 0.0);
  charge_acceleration = vector2d(0.0, 0.0);
}

// Detect when two opposite charges mesh together
void Charge::detect_collision (double aspect_ratio) {
  double temp;
  if (charge_position.x >= SCALE*aspect_ratio || charge_position.x <= -SCALE*aspect_ratio || charge_position.y >= SCALE || charge_position.y <= -SCALE) draw_or_not = 0;
  else {
    for (int i=0; i<MAX_NUM_SOURCE; i++) {
      if ((ptr_source_list+i)->draw_or_not == 1) {
        temp = ((((ptr_source_list+i)->charge_position)-charge_position).abs());
        if (temp <= SCALE/50) {
          draw_or_not = 0;
          reset_charge(vector2d(0.0, 0.0));
          break;
        }
      }
    }
  }
}
